---
title: Mapping SAS Formats to R
subtitle: A Comprehensive Guide for the SAS Programmer
author:
  - name: Michael Walshe
    email: michael.walshe@katalyzedata.com
format:
  html:
    df-print: kable
    mainfont: Montserrat
    embed-resources: true
  docx:
    reference-doc: kd-quarto-ref-doc.docx
knitr:
  opts_chunk: 
    comment: "#>" 
---

# Introduction to SAS Formats

SAS formats and informats are a swiss-army knife of data manipulation, providing in one package methods to:

-   Read formatted data as a different type, for example to read a value of £1,000.00 as a numeric value.
-  Apply a 'mask' to data. This means that you can change the way that data is displayed, without changing the underlying data (e.g. a value of `-0.6534` could print as `(65.3%)`)
-   Group data into bins, based on custom conditions and logic
-   Perform a look-up from one value to another

Because of the sheer number of different use-cases for SAS formats, there is no single function or package in R which can fully replace it. However, this can be seen as a benefit, logically separating the different functionalities and making R easier to understand and use. In this article we'll assess a few different methods for each of the above use-cases, starting with the simplest.

# Look-ups

A SAS format, typically a user-defined one, can be used as a look-up table - for example from a region code to the full name of that region. In R this could be achieved with:

-   A join or merge
-   A named vector
-   Using a function such as `dplyr::case_when` to encode the look-up

## Method 1: Using A Join

Joins are a widespread method for performing some form of look-up, we will demonstrate using the base R `merge` function.

```{r}
my_data <- data.frame(
  region_code = c("SA", "SA", "E", "AS", "AN", "NA"),
  measure = runif(6)
)

lookup_df <- data.frame(
  region_code = c("E", "NA", "SA", "AS", "AF", "AU", "AN"),
  region_full = c(
    "Europe",
    "North America",
    "South America",
    "Asia",
    "Africa",
    "Australia",
    "Antartica"
  )
)

merge(my_data, lookup_df)
```

## Method 2: Using A Named Vector

Where you have a simple mapping of keys to values, a named vector can be a good method in R to move from one to the other. Note here that the keys should be the *names* of the vector, and the values are the elements. Then indexing using a key produces the value.

```{r}
lookup_vector <- c(
  "E" = "Europe",
  "NA" = "North America",
  "SA" = "South America",
  "AS" = "Asia",
  "AF" = "Africa",
  "AU" = "Australia",
  "AN" = "Antartica"
)

my_data$region_full <- lookup_vector[my_data$region_code]
```

Note that if the keys were numbers, we would have to create the named vector in two steps, first creating a vector of values then assigning to the `names` function. However this is not recommended, as it can be unclear what e.g. `lookup_vector[3]` should return.

## Method 3: Using [`{dplyr}`](https://dplyr.tidyverse.org/)

`dplyr::case_when()` is a very useful way to create a new vector based on several conditions. It is similar to a case when expression in SQL. For a simple look-up, the conditions will be equality with our input vector. This also lets us map values not in our look-up table to some default.

```{r}
my_data$region_full <- dplyr::case_when(
  my_data$region_code == "E" ~ "Europe",
  my_data$region_code == "NA" ~ "North America",
  my_data$region_code == "SA" ~ "South America",
  my_data$region_code == "AS" ~ "Asia",
  my_data$region_code == "AF" ~ "Africa",
  my_data$region_code == "AU" ~ "Australia",
  my_data$region_code == "AN" ~ "Antartica",
  .default = "Unknown"
)
```

This is a little clunky and includes some repetition, but we can use the more modern `case_match` function to improve it, and at the same time move this into a function to let us easily re-use this mapping.

```{r}
region_lookup <- function(x) {
  dplyr::case_match(
    x,
    "E" ~ "Europe",
    "NA" ~ "North America",
    "SA" ~ "South America",
    "AS" ~ "Asia",
    "AF" ~ "Africa",
    "AU" ~ "Australia",
    "AN" ~ "Antartica",
    .default = "Unknown"
  )
}

region_lookup(my_data$region_code)
```

# Binning

For those unaware, "binning" is the process of grouping data in ranges of values. SAS user defined formats can be created to group numeric values into these bins. It's used in a variety of situations, from analysis and visualisation to statistics. As such, there is a base R function `cut` that can provide most of the functionality we need.


The simplest behaviour is to provide the number of bins, R will create a `factor` with labels indicating the intervals.

```{r}
ages <- c(59, 22, 20, 62, 30)

cut(ages, breaks=3)
```

We can also define custom intervals and labels, note that labels needs to be 1 element shorter than breaks.

```{r}
cut(
  ages,
  breaks=c(0, 40, 60, 100),
  labels=c("Young", "Middle-Aged", "Old")
)
```

There are many packages in R that provide a function to bin data for different use-cases, as one example we can again use `dplyr::case_when()`, this time to group data. This produces a character vector rather than factor.

```{r}
dplyr::case_when(
  ages <= 40 ~ "Young",
  ages <= 60 ~ "Middle-Aged",
  .default = "Old"
)
```

# Masks

Using a format as a "mask" for data is the most common use-case in SAS, keeping the underlying data the same but applying formatting when it is displayed. There are several different methods we can use to replicate this in R.

## Method 1: Base R

Using Base R, there are several different functions that can format data.

The first we'll use is the `format()` function, which can format any R object for printing, but is typically used for numeric vectors and has a large set of options:

```{r}
numbers <- runif(10, -1000000, 1000000)

format(numbers, justify="right", width="10", big.mark=",") |> print()

format(numbers, digits=3, scientific=TRUE) |> print()
```

Alternatively, the `sprintf` function provides a familiar interface to those used to C style formatting, for more detail run `?sprintf`.

```{r}
sprintf("$%.2f", numbers)
```

## Method 2: [`{scales}`](https://scales.r-lib.org/)

The `{scales}` package is used by `{ggplot2}` to scale data for graphs, but it also includes some useful formatting functions that can help with common formats. For example:

```{r}
scales::label_dollar(prefix="£", style_negative="parens")(numbers)
```

Note that all the `scale::label_...` functions return another function, and we've passed the `numbers` vector into this. There are label functions for currency, percents, dates, time, mathematics, SI units, p-values, and more! If a particular label is used frequently in your code, it may be helpful to assign it to a helper function

```{r}
percent <- scales::label_percent(
  accuracy=0.1,
  suffix=" %",
  decimal.mark=",",
  style_negative="parens"
)

percent(runif(5, -1, 1))
```


## Method 3: [`{formatttable}`](https://renkun-ken.github.io/formattable/)

All the examples covered so far have 1 key difference to SAS formats, they return the data converted to a new format, rather than the original data with a mask that applies when printing. For this, we can use `{formattable}`. This lets us apply formats to a vector or data.frame, and then continue to work with them as if they were standard R vectors. Only when it comes time to print does the format get applied.

For example:
```{r}
values <- runif(5, -1, 1)

percs <- formattable::percent(values)

print(percs)

print(percs ** 2)
```

This is not limited to standard numeric formats, for which `{formattable}` includes methods for: digits, commas, percents, accounting, currency, and scientific notation. There are also advanced methods for styling the output table, for example conditional formatting similar to Excel output:

```{r}
#| eval: false
formattable::formattable(
  my_data,
  list(measure=formattable::color_tile("white", "pink"))
)
```

```{r}
#| echo: false
if (knitr::is_html_output()) {
  formattable::formattable(
    my_data,
    list(measure=formattable::color_tile("white", "pink"))
  )
} else {
  knitr::include_graphics("table.png")
}
```

Note however that these formats will not be persisted unless the data is saved in an Rdata or RDS format.

# Reading in Data

The final use of a SAS format that we'd like to replicate is reading in character data as numeric. The simplest way to do this is using `parse_number` from [`{readr}`](https://readr.tidyverse.org/), which provides a method to ignore non-numeric data in a column and attempt to parse it as a number:

```{r}
readr::parse_number(c("£1,000.00"))
```

And for date formats, `{readr}` also provides `readr::parse_date` or `readr::parse_datetime`.


However, when it comes to more complex formats (e.g. "(82.5%)") this will not take into account that it is a percentage and negative, and so more custom methods must be used:

```{r}
values <- c("(82.5%)", "2%", "28.55%")

my_format <- function(x){
  x |> 
    stringr::str_replace_all(c("\\(" = "-", "\\)" = "")) |> 
    readr::parse_number() / 100
}

my_format(values)
```

# Honourable Mentions

- An incredibly useful package for formatting tables for output is [`{gt}`](https://gt.rstudio.com/index.html). This also includes a large number of formatting functions; however these can only be used at the point of printing the data and you cannot extract the formatted data, therefore this was not featured.

- An excellent package that provides a very large number of built-in formats is [`{numform}`](https://cran.r-project.org/web/packages/numform/index.html). This had the most included formats of all packages considered, however due to its relatively low usage (~1.2K downloads per month) the `{scales}` package was featured instead.

- Another package to mention is [`{fmtr}`](https://fmtr.r-sassy.org/articles/fmtr.html), which is designed to try and replicate the experience of SAS user-defined formats in R, including conditions and format catalogues. However, it also has limited popularity, and further it's best practice to try to write idiomatic R rather than replicate SAS exactly.

- The `{formattable}` package has unreleased functions for parsing different formats from text, for example `parse_accounting`. On release, these may be a good method to read in formatted data.
